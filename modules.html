<!DOCTYPE html>
<html>
	<head>
		<title>SMotaal's Modules</title>
		<meta charset="utf-8" />
		<meta
			name="viewport"
			content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=0, viewport-fit=cover"
		/>
		<style>
			output.console,
			output.console pre,
			output.console code {
				font-family: 'Iosevka', 'Fira Code', monospace;
				background-clip: padding-box;
				margin: 0;
				/* border-collapse: collapse; */
			}

			output.console pre {
				padding: 0.5em 0.25em;
				border: 1px solid transparent;
			}

			output.console pre:not(.group) {
				border-bottom-color: #9994;
			}

			output.console code {
				padding: 0;
			}

			output.console * + *::before {
				display: inline-block;
				content: '';
				width: 0.5em;
			}

			output.console hr {
				border-style: solid;
				border-color: #9994;
			}

			output.console .log {
				color: #333;
			}

			output.console .group > :first-child {
				font-weight: bold;
				display: list-item;
				list-style-type: none;
				padding-top: 0.5em;
				padding-bottom: 0.5em;
				margin-left: 0.75em;
			}

			output.console .group > :first-child::before {
				color: #9999;
				display: inline-block;
				width: 0;
				position: relative;
				left: -0.875em;
				/* text-align: center; */
				content: 'â–¾';
			}

			output.console .group > :not(:first-child) {
				padding-left: 1em;
				border-left-color: #9994;
				border-bottom-color: #9994;
			}

			output.console .warn {
				background-color: #fef9e7;
				/* background-image: linear-gradient(to left,#9999 0%, #9999 100%); */
			}
			output.console .info {
				color: green;
			}
			output.console .error {
				color: red;
			}

			output.console .number-value,
			output.console .Number-object {
				color: cornflowerblue;
			}
			output.console .boolean-value,
			output.console .Boolean-object {
				color: steelblue;
			}
			output.console .undefined-value,
			output.console .null-value {
				color: #999;
			}

			output.console .string-value {
				color: #666;
			}

			output.console code span .String-object {
				--class: 'String';
			}

			output.console * {
				quotes: none;
			}

			output.console .object-value {
				quotes: '{ ' ' }';
			}

			output.console [data-kind='Array'] {
				quotes: '[ ' ' ]';
			}

			output.console .string-value {
				quotes: '"' '"';
			}
			output.console .String-object {
				quotes: '{ "' '" }';
			}

			output.console [data-class] {
				--class: attr(data-class);
			}

			output.console code span .string-value::before {
				content: open-quote;
			}

			output.console code span .string-value::after {
				content: close-quote;
			}

			output.console :not([data-kind='Error']).object-value[data-class]::before {
				content: var(--class, 'Object') ' ' open-quote;
				display: inline;
			}

			output.console :not([data-kind='Error']).object-value[data-class]::after {
				content: close-quote;
				display: inline;
			}
		</style>
	</head>

	<body>
		<script>
			if (document.currentScript) {
				const output = document.body.insertBefore(document.createElement('output'), document.currentScript);

				output.className = 'console';

				const Span = (...content) => {
					const span = document.createElement('span');
					content.length && span.append(...content);
					return span;
				};

				const textify = (item, type, body) => {
					let kind;
					const element =
						((type = item === null ? null : typeof item) === 'object' &&
							(('textContent' in item && item instanceof (kind = Node) && Span(item)) ||
								(item instanceof (kind = Error) &&
									Object.assign(Span(new Text(`${item}`)), {className: 'error', title: `${item.stack}`})) ||
								(item instanceof (kind = String) && Span(new Text(item))) ||
								(item instanceof (kind = Promise) &&
									(item.then(content => body.append(Span(new Text('<resolved> ')), textify(content))),
									item.catch(reason => body.append(Span(new Text('<rejected> ')), textify(reason))),
									Span((body = Span())))) ||
								(item instanceof (kind = Array) &&
									Span(...[].concat(...item.map((v, i) => [textify(v), new Text(', ')])).slice(0, -1))) ||
								((kind = undefined),
								Span(
									new Text(
										JSON.stringify(item, null, 1).replace(/^\{\s*([^]*)\s*\}$/, (m, a) =>
											(a.includes('\n') ? a.replace(/\s*\n(\s?)\s*/g, '$1') : a).replace(/"([^\s\d]\S*)": /g, '$1: '),
										),
									),
								)))) ||
						(type === 'function' && Span(new Text(`${item}`))) ||
						Span(new Text(type !== 'symbol' ? `${item}` : ''));

					if (element && element.classList) {
						let className;

						if (type === 'object') {
							className = (Object.getPrototypeOf(item) || Object).constructor.name;
							kind && kind.name && (kind = kind.name);
							element.classList.add(`${className || kind}-object`);
						} else if (type === 'function') {
							className = Object.getPrototypeOf(item).constructor.name;
							type =
								className === 'GeneratorFunction'
									? 'generator-function'
									: !Object.prototype.hasOwnProperty.call(item, 'prototype')
									? 'arrow-function'
									: !item.prototype ||
									  item.prototype.constructor !== item ||
									  Object.getOwnPropertyDescriptor(item, 'prototype').writable
									? 'function'
									: 'class';
							element.classList.add(`${className}-object`);
						}
						element.classList.add(`${type}-value`);
						className && element.setAttribute('data-class', className);
						kind && element.setAttribute('data-kind', kind);
						item == null || (type === 'object' && !element.classList.add());
					}
					return element;
				};

				const append = (parent, ...items) => {
					const fragment = document.createDocumentFragment();
					for (const item of items) fragment.appendChild(textify(item));
					const element = parent.appendChild(document.createElement('code'));
					element.appendChild(fragment);
					return element;
				};

				const Parent = ({tag = 'pre', class: className, ...properties}) =>
					Object.assign(document.createElement(tag), {className, ...properties});

				const spans = {
					log: Parent({class: 'log'}),
					warn: Parent({class: 'warn'}),
					error: Parent({class: 'error'}),
					info: Parent({class: 'info'}),
					group: Parent({class: 'group log'}),
					groupCollapsed: Parent({class: 'groupCollapsed group log'}),
					groupEnd: Parent({class: 'groupEnd', hidden: true}),
					trace: Parent({class: 'trace'}),
				};

				{
					const {dir, log, warn, error, info, group, groupCollapsed, groupEnd, trace} = console;

					let parent = output;

					({
						dir: console.dir = dir,
						log: console.log = log,
						warn: console.warn = warn,
						error: console.error = error,
						info: console.info = info,
						group: console.group = group,
						groupEnd: console.groupEnd = groupEnd,
						groupCollapsed: console.groupCollapsed = groupCollapsed,
						trace: console.trace = trace,
					} = new class {
						log() {
							append(parent.appendChild(spans.log.cloneNode(true)), ...arguments);
							log(...arguments);
						}

						dir() {
							console.log(arguments[0]);
						}

						warn() {
							append(parent.appendChild(spans.warn.cloneNode(true)), ...arguments);
							warn(...arguments);
						}

						error() {
							append(parent.appendChild(spans.error.cloneNode(true)), ...arguments);
							error(...arguments);
						}

						info() {
							append(parent.appendChild(spans.info.cloneNode(true)), ...arguments);
							info(...arguments);
						}

						group() {
							append((parent = parent.appendChild(spans.group.cloneNode(true))), ...arguments);
							group(...arguments);
						}

						groupCollapsed() {
							append((parent = parent.appendChild(spans.groupCollapsed.cloneNode(true))), ...arguments);
							groupCollapsed(...arguments);
						}

						groupEnd() {
							append(parent.appendChild(spans.groupEnd.cloneNode(true)));
							parent = parent.parentElement;
							groupEnd();
						}

						trace() {
							const stack = new Error('').stack.replace(/^.*\n.*\n/, '\n');
							append(parent.appendChild(spans.trace.cloneNode(true)), 'Trace:', ...arguments, stack);
							log(`Trace:`, ...arguments, new Error('').stack.replace(/^.*\n.*\n/, '\n'), stack);
							// trace(...arguments);
						}
					}());
				}
			}
		</script>
		<script type="module" src="./esm.mjs"></script>
	</body>
</html>
